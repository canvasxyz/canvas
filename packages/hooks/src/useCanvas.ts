import { Action, ActionPayload, getActionSignatureData } from "@canvas-js/interfaces"
import { useCallback, useContext, useState } from "react"

import { CanvasContext, ApplicationData } from "./CanvasContext.js"
import { urlJoin, Dispatch, getCanvasSessionKey, getLatestBlock } from "./utils.js"

export function useCanvas(): {
	isLoading: boolean
	isPending: boolean
	isReady: boolean
	error: Error | null
	host: string | null
	data: ApplicationData | null
	dispatch: Dispatch
} {
	const {
		isLoading,
		error,
		host,
		data,
		signer,
		sessionWallet,
		setSessionWallet,
		sessionExpiration,
		setSessionExpiration,
	} = useContext(CanvasContext)

	const [isPending, setIsPending] = useState(false)

	const dispatch: Dispatch = useCallback(
		async (call, ...args) => {
			console.log("dispatch:", call, args)
			if (host === null) {
				throw new Error("no host configured")
			} else if (signer === null) {
				throw new Error("dispatch() called without a provider")
			} else if (sessionWallet === null || sessionExpiration === null) {
				throw new Error("dispatch() called while logged out")
			} else if (data === null) {
				throw new Error("dispatch called before the application connection was established")
			}

			const timestamp = Date.now()
			if (sessionExpiration < timestamp) {
				setSessionWallet(null)
				setSessionExpiration(null)
				throw new Error("Session expired. Please log in again.")
			}

			setIsPending(true)
			console.log("set pending to true")

			try {
				const block = await getLatestBlock(signer.provider)
				console.log("got block", block)

				const address = await signer.getAddress()
				console.log("from address", address)

				const payload: ActionPayload = {
					from: address,
					spec: data.uri,
					call,
					args,
					timestamp,
					blockhash: block.blockhash,
					chain: block.chain,
					chainId: block.chainId,
				}

				const signatureData = getActionSignatureData(payload)
				const signature = await sessionWallet._signTypedData(...signatureData)
				console.log("got signature", signature)

				const action: Action = { session: sessionWallet.address, signature, payload }

				const res = await fetch(urlJoin(host, "actions"), {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(action),
				})

				if (!res.ok) {
					const message = await res.text()
					if (message === "session not found" || message === "session expired") {
						setSessionWallet(null)
						setSessionExpiration(null)
						const sessionKey = getCanvasSessionKey(signer._address)
						localStorage.removeItem(sessionKey)
					}

					throw new Error(message)
				}

				const { hash } = await res.json()
				return { hash }
			} finally {
				setIsPending(false)
			}
		},
		[host, data, signer, sessionWallet, sessionExpiration]
	)

	const isReady = !isPending && sessionWallet !== null
	return { isLoading, isPending, isReady, error, host, data, dispatch }
}
